/*
 * generated by Xtext 2.10.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.myLanguage.BaroAltSent;
import org.xtext.example.mydsl.myLanguage.BaroSent;
import org.xtext.example.mydsl.myLanguage.BatteryLevelSent;
import org.xtext.example.mydsl.myLanguage.BatterySent;
import org.xtext.example.mydsl.myLanguage.CENTIMETER;
import org.xtext.example.mydsl.myLanguage.CirclePosition;
import org.xtext.example.mydsl.myLanguage.CompStatusSent;
import org.xtext.example.mydsl.myLanguage.CompleteTimeSent;
import org.xtext.example.mydsl.myLanguage.DistanceToLocationSent;
import org.xtext.example.mydsl.myLanguage.DistanceToObstaclesSent;
import org.xtext.example.mydsl.myLanguage.EnvironmentSent;
import org.xtext.example.mydsl.myLanguage.EqualSent;
import org.xtext.example.mydsl.myLanguage.GPSReadingSent;
import org.xtext.example.mydsl.myLanguage.GPSSent;
import org.xtext.example.mydsl.myLanguage.Given;
import org.xtext.example.mydsl.myLanguage.GreaterSent;
import org.xtext.example.mydsl.myLanguage.HOUR;
import org.xtext.example.mydsl.myLanguage.KILOMETER;
import org.xtext.example.mydsl.myLanguage.KMH;
import org.xtext.example.mydsl.myLanguage.KMS;
import org.xtext.example.mydsl.myLanguage.LessSent;
import org.xtext.example.mydsl.myLanguage.METER;
import org.xtext.example.mydsl.myLanguage.MH;
import org.xtext.example.mydsl.myLanguage.MILLIMETER;
import org.xtext.example.mydsl.myLanguage.MINUTES;
import org.xtext.example.mydsl.myLanguage.MS;
import org.xtext.example.mydsl.myLanguage.MissionGoalSent;
import org.xtext.example.mydsl.myLanguage.MissionRiskLevelSent;
import org.xtext.example.mydsl.myLanguage.MissionStatusSent;
import org.xtext.example.mydsl.myLanguage.MyLanguagePackage;
import org.xtext.example.mydsl.myLanguage.NotificationSent;
import org.xtext.example.mydsl.myLanguage.PayloadSent;
import org.xtext.example.mydsl.myLanguage.PeopleNumbSent;
import org.xtext.example.mydsl.myLanguage.PeoplePosSent;
import org.xtext.example.mydsl.myLanguage.PercentUnit;
import org.xtext.example.mydsl.myLanguage.RiskSent;
import org.xtext.example.mydsl.myLanguage.RobotAutoPilot;
import org.xtext.example.mydsl.myLanguage.RobotDistanceSent;
import org.xtext.example.mydsl.myLanguage.RobotPositionSent;
import org.xtext.example.mydsl.myLanguage.RobotSpeedSent;
import org.xtext.example.mydsl.myLanguage.RobotStateSent;
import org.xtext.example.mydsl.myLanguage.SECONDS;
import org.xtext.example.mydsl.myLanguage.SonarDistanceSent;
import org.xtext.example.mydsl.myLanguage.SonarSent;
import org.xtext.example.mydsl.myLanguage.SpherePosition;
import org.xtext.example.mydsl.myLanguage.Test;
import org.xtext.example.mydsl.myLanguage.TestFile;
import org.xtext.example.mydsl.myLanguage.Then;
import org.xtext.example.mydsl.myLanguage.TimeInterval;
import org.xtext.example.mydsl.myLanguage.ToleranceSent;
import org.xtext.example.mydsl.myLanguage.When;
import org.xtext.example.mydsl.services.MyLanguageGrammarAccess;

@SuppressWarnings("all")
public class MyLanguageSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyLanguageGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MyLanguagePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MyLanguagePackage.BARO_ALT_SENT:
				sequence_BaroAltSent(context, (BaroAltSent) semanticObject); 
				return; 
			case MyLanguagePackage.BARO_SENT:
				sequence_BaroSent(context, (BaroSent) semanticObject); 
				return; 
			case MyLanguagePackage.BATTERY_LEVEL_SENT:
				sequence_BatteryLevelSent(context, (BatteryLevelSent) semanticObject); 
				return; 
			case MyLanguagePackage.BATTERY_SENT:
				sequence_BatterySent(context, (BatterySent) semanticObject); 
				return; 
			case MyLanguagePackage.CENTIMETER:
				sequence_CENTIMETER(context, (CENTIMETER) semanticObject); 
				return; 
			case MyLanguagePackage.CIRCLE_POSITION:
				sequence_CirclePosition(context, (CirclePosition) semanticObject); 
				return; 
			case MyLanguagePackage.COMP_STATUS_SENT:
				sequence_CompStatusSent(context, (CompStatusSent) semanticObject); 
				return; 
			case MyLanguagePackage.COMPLETE_TIME_SENT:
				sequence_CompleteTimeSent(context, (CompleteTimeSent) semanticObject); 
				return; 
			case MyLanguagePackage.DISTANCE_TO_LOCATION_SENT:
				sequence_DistanceToLocationSent(context, (DistanceToLocationSent) semanticObject); 
				return; 
			case MyLanguagePackage.DISTANCE_TO_OBSTACLES_SENT:
				sequence_DistanceToObstaclesSent(context, (DistanceToObstaclesSent) semanticObject); 
				return; 
			case MyLanguagePackage.ENVIRONMENT_SENT:
				sequence_EnvironmentSent(context, (EnvironmentSent) semanticObject); 
				return; 
			case MyLanguagePackage.EQUAL_SENT:
				sequence_EqualSent(context, (EqualSent) semanticObject); 
				return; 
			case MyLanguagePackage.GPS_READING_SENT:
				sequence_GPSReadingSent(context, (GPSReadingSent) semanticObject); 
				return; 
			case MyLanguagePackage.GPS_SENT:
				sequence_GPSSent(context, (GPSSent) semanticObject); 
				return; 
			case MyLanguagePackage.GIVEN:
				sequence_Given(context, (Given) semanticObject); 
				return; 
			case MyLanguagePackage.GREATER_SENT:
				sequence_GreaterSent(context, (GreaterSent) semanticObject); 
				return; 
			case MyLanguagePackage.HOUR:
				sequence_HOUR(context, (HOUR) semanticObject); 
				return; 
			case MyLanguagePackage.KILOMETER:
				sequence_KILOMETER(context, (KILOMETER) semanticObject); 
				return; 
			case MyLanguagePackage.KMH:
				sequence_KMH(context, (KMH) semanticObject); 
				return; 
			case MyLanguagePackage.KMS:
				sequence_KMS(context, (KMS) semanticObject); 
				return; 
			case MyLanguagePackage.LESS_SENT:
				sequence_LessSent(context, (LessSent) semanticObject); 
				return; 
			case MyLanguagePackage.METER:
				sequence_METER(context, (METER) semanticObject); 
				return; 
			case MyLanguagePackage.MH:
				sequence_MH(context, (MH) semanticObject); 
				return; 
			case MyLanguagePackage.MILLIMETER:
				sequence_MILLIMETER(context, (MILLIMETER) semanticObject); 
				return; 
			case MyLanguagePackage.MINUTES:
				sequence_MINUTES(context, (MINUTES) semanticObject); 
				return; 
			case MyLanguagePackage.MS:
				sequence_MS(context, (MS) semanticObject); 
				return; 
			case MyLanguagePackage.MISSION_GOAL_SENT:
				sequence_MissionGoalSent(context, (MissionGoalSent) semanticObject); 
				return; 
			case MyLanguagePackage.MISSION_RISK_LEVEL_SENT:
				sequence_MissionRiskLevelSent(context, (MissionRiskLevelSent) semanticObject); 
				return; 
			case MyLanguagePackage.MISSION_STATUS_SENT:
				sequence_MissionStatusSent(context, (MissionStatusSent) semanticObject); 
				return; 
			case MyLanguagePackage.NOTIFICATION_SENT:
				sequence_NotificationSent(context, (NotificationSent) semanticObject); 
				return; 
			case MyLanguagePackage.PAYLOAD_SENT:
				sequence_PayloadSent(context, (PayloadSent) semanticObject); 
				return; 
			case MyLanguagePackage.PEOPLE_NUMB_SENT:
				sequence_PeopleNumbSent(context, (PeopleNumbSent) semanticObject); 
				return; 
			case MyLanguagePackage.PEOPLE_POS_SENT:
				sequence_PeoplePosSent(context, (PeoplePosSent) semanticObject); 
				return; 
			case MyLanguagePackage.PERCENT_UNIT:
				sequence_PercentUnit(context, (PercentUnit) semanticObject); 
				return; 
			case MyLanguagePackage.RISK_SENT:
				sequence_RiskSent(context, (RiskSent) semanticObject); 
				return; 
			case MyLanguagePackage.ROBOT_AUTO_PILOT:
				sequence_RobotAutoPilot(context, (RobotAutoPilot) semanticObject); 
				return; 
			case MyLanguagePackage.ROBOT_DISTANCE_SENT:
				sequence_RobotDistanceSent(context, (RobotDistanceSent) semanticObject); 
				return; 
			case MyLanguagePackage.ROBOT_POSITION_SENT:
				sequence_RobotPositionSent(context, (RobotPositionSent) semanticObject); 
				return; 
			case MyLanguagePackage.ROBOT_SPEED_SENT:
				sequence_RobotSpeedSent(context, (RobotSpeedSent) semanticObject); 
				return; 
			case MyLanguagePackage.ROBOT_STATE_SENT:
				sequence_RobotStateSent(context, (RobotStateSent) semanticObject); 
				return; 
			case MyLanguagePackage.SECONDS:
				sequence_SECONDS(context, (SECONDS) semanticObject); 
				return; 
			case MyLanguagePackage.SONAR_DISTANCE_SENT:
				sequence_SonarDistanceSent(context, (SonarDistanceSent) semanticObject); 
				return; 
			case MyLanguagePackage.SONAR_SENT:
				sequence_SonarSent(context, (SonarSent) semanticObject); 
				return; 
			case MyLanguagePackage.SPHERE_POSITION:
				sequence_SpherePosition(context, (SpherePosition) semanticObject); 
				return; 
			case MyLanguagePackage.TEST:
				sequence_Test(context, (Test) semanticObject); 
				return; 
			case MyLanguagePackage.TEST_FILE:
				sequence_TestFile(context, (TestFile) semanticObject); 
				return; 
			case MyLanguagePackage.THEN:
				sequence_Then(context, (Then) semanticObject); 
				return; 
			case MyLanguagePackage.TIME_INTERVAL:
				sequence_TimeInterval(context, (TimeInterval) semanticObject); 
				return; 
			case MyLanguagePackage.TOLERANCE_SENT:
				sequence_ToleranceSent(context, (ToleranceSent) semanticObject); 
				return; 
			case MyLanguagePackage.WHEN:
				sequence_When(context, (When) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     BaroAltSent returns BaroAltSent
	 *
	 * Constraint:
	 *     (sent=GreaterSent | sent=LessSent | sent=EqualSent)
	 */
	protected void sequence_BaroAltSent(ISerializationContext context, BaroAltSent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatementBody returns BaroSent
	 *     BaroSent returns BaroSent
	 *
	 * Constraint:
	 *     (sent=BaroAltSent | sent=CompStatusSent)
	 */
	protected void sequence_BaroSent(ISerializationContext context, BaroSent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BatteryLevelSent returns BatteryLevelSent
	 *
	 * Constraint:
	 *     (sent=GreaterSent | sent=LessSent | sent=EqualSent)
	 */
	protected void sequence_BatteryLevelSent(ISerializationContext context, BatteryLevelSent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatementBody returns BatterySent
	 *     BatterySent returns BatterySent
	 *
	 * Constraint:
	 *     (sent=BatteryLevelSent | sent=CompStatusSent)
	 */
	protected void sequence_BatterySent(ISerializationContext context, BatterySent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DistanceUnit returns CENTIMETER
	 *     CENTIMETER returns CENTIMETER
	 *
	 * Constraint:
	 *     value=DOUBLE
	 */
	protected void sequence_CENTIMETER(ISerializationContext context, CENTIMETER semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyLanguagePackage.Literals.DISTANCE_UNIT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLanguagePackage.Literals.DISTANCE_UNIT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCENTIMETERAccess().getValueDOUBLEParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CirclePosition returns CirclePosition
	 *
	 * Constraint:
	 *     tolerance=DistanceUnit
	 */
	protected void sequence_CirclePosition(ISerializationContext context, CirclePosition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyLanguagePackage.Literals.CIRCLE_POSITION__TOLERANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLanguagePackage.Literals.CIRCLE_POSITION__TOLERANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCirclePositionAccess().getToleranceDistanceUnitParserRuleCall_4_0(), semanticObject.getTolerance());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CompStatusSent returns CompStatusSent
	 *
	 * Constraint:
	 *     status=COMPSTATUS
	 */
	protected void sequence_CompStatusSent(ISerializationContext context, CompStatusSent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyLanguagePackage.Literals.COMP_STATUS_SENT__STATUS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLanguagePackage.Literals.COMP_STATUS_SENT__STATUS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompStatusSentAccess().getStatusCOMPSTATUSParserRuleCall_2_0(), semanticObject.getStatus());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CompleteTimeSent returns CompleteTimeSent
	 *
	 * Constraint:
	 *     (value='always' | value='never')
	 */
	protected void sequence_CompleteTimeSent(ISerializationContext context, CompleteTimeSent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DistanceToLocationSent returns DistanceToLocationSent
	 *
	 * Constraint:
	 *     (posX=DistanceUnit posY=DistanceUnit posZ=DistanceUnit (body=GreaterSent | body=LessSent | body=EqualSent) tolerance=ToleranceSent?)
	 */
	protected void sequence_DistanceToLocationSent(ISerializationContext context, DistanceToLocationSent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DistanceToObstaclesSent returns DistanceToObstaclesSent
	 *
	 * Constraint:
	 *     ((body=GreaterSent | body=LessSent | body=EqualSent) tolerance=ToleranceSent?)
	 */
	protected void sequence_DistanceToObstaclesSent(ISerializationContext context, DistanceToObstaclesSent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatementBody returns EnvironmentSent
	 *     EnvironmentSent returns EnvironmentSent
	 *
	 * Constraint:
	 *     (body=GreaterSent | body=LessSent | body=EqualSent)
	 */
	protected void sequence_EnvironmentSent(ISerializationContext context, EnvironmentSent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EqualSent returns EqualSent
	 *
	 * Constraint:
	 *     (amount=DistanceUnit | amount=PercentUnit | amount=SpeedUnit)
	 */
	protected void sequence_EqualSent(ISerializationContext context, EqualSent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GPSReadingSent returns GPSReadingSent
	 *
	 * Constraint:
	 *     (posX=DistanceUnit posY=DistanceUnit posZ=DistanceUnit (tolerance=CirclePosition | tolerance=SpherePosition)?)
	 */
	protected void sequence_GPSReadingSent(ISerializationContext context, GPSReadingSent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatementBody returns GPSSent
	 *     GPSSent returns GPSSent
	 *
	 * Constraint:
	 *     (sent=GPSReadingSent | sent=CompStatusSent)
	 */
	protected void sequence_GPSSent(ISerializationContext context, GPSSent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Given
	 *     Given returns Given
	 *
	 * Constraint:
	 *     body=StatementBody
	 */
	protected void sequence_Given(ISerializationContext context, Given semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyLanguagePackage.Literals.GIVEN__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLanguagePackage.Literals.GIVEN__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGivenAccess().getBodyStatementBodyParserRuleCall_1_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GreaterSent returns GreaterSent
	 *
	 * Constraint:
	 *     (amount=DistanceUnit | amount=PercentUnit | amount=SpeedUnit)
	 */
	protected void sequence_GreaterSent(ISerializationContext context, GreaterSent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TimeUnit returns HOUR
	 *     HOUR returns HOUR
	 *
	 * Constraint:
	 *     value=PositiveDouble
	 */
	protected void sequence_HOUR(ISerializationContext context, HOUR semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyLanguagePackage.Literals.TIME_UNIT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLanguagePackage.Literals.TIME_UNIT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHOURAccess().getValuePositiveDoubleParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DistanceUnit returns KILOMETER
	 *     KILOMETER returns KILOMETER
	 *
	 * Constraint:
	 *     value=DOUBLE
	 */
	protected void sequence_KILOMETER(ISerializationContext context, KILOMETER semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyLanguagePackage.Literals.DISTANCE_UNIT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLanguagePackage.Literals.DISTANCE_UNIT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getKILOMETERAccess().getValueDOUBLEParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpeedUnit returns KMH
	 *     KMH returns KMH
	 *
	 * Constraint:
	 *     (x=DOUBLE y=DOUBLE z=DOUBLE)
	 */
	protected void sequence_KMH(ISerializationContext context, KMH semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyLanguagePackage.Literals.SPEED_UNIT__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLanguagePackage.Literals.SPEED_UNIT__X));
			if (transientValues.isValueTransient(semanticObject, MyLanguagePackage.Literals.SPEED_UNIT__Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLanguagePackage.Literals.SPEED_UNIT__Y));
			if (transientValues.isValueTransient(semanticObject, MyLanguagePackage.Literals.SPEED_UNIT__Z) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLanguagePackage.Literals.SPEED_UNIT__Z));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getKMHAccess().getXDOUBLEParserRuleCall_1_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getKMHAccess().getYDOUBLEParserRuleCall_3_0(), semanticObject.getY());
		feeder.accept(grammarAccess.getKMHAccess().getZDOUBLEParserRuleCall_5_0(), semanticObject.getZ());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpeedUnit returns KMS
	 *     KMS returns KMS
	 *
	 * Constraint:
	 *     (x=DOUBLE y=DOUBLE z=DOUBLE)
	 */
	protected void sequence_KMS(ISerializationContext context, KMS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyLanguagePackage.Literals.SPEED_UNIT__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLanguagePackage.Literals.SPEED_UNIT__X));
			if (transientValues.isValueTransient(semanticObject, MyLanguagePackage.Literals.SPEED_UNIT__Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLanguagePackage.Literals.SPEED_UNIT__Y));
			if (transientValues.isValueTransient(semanticObject, MyLanguagePackage.Literals.SPEED_UNIT__Z) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLanguagePackage.Literals.SPEED_UNIT__Z));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getKMSAccess().getXDOUBLEParserRuleCall_1_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getKMSAccess().getYDOUBLEParserRuleCall_3_0(), semanticObject.getY());
		feeder.accept(grammarAccess.getKMSAccess().getZDOUBLEParserRuleCall_5_0(), semanticObject.getZ());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LessSent returns LessSent
	 *
	 * Constraint:
	 *     (amount=DistanceUnit | amount=PercentUnit | amount=SpeedUnit)
	 */
	protected void sequence_LessSent(ISerializationContext context, LessSent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DistanceUnit returns METER
	 *     METER returns METER
	 *
	 * Constraint:
	 *     value=DOUBLE
	 */
	protected void sequence_METER(ISerializationContext context, METER semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyLanguagePackage.Literals.DISTANCE_UNIT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLanguagePackage.Literals.DISTANCE_UNIT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMETERAccess().getValueDOUBLEParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpeedUnit returns MH
	 *     MH returns MH
	 *
	 * Constraint:
	 *     (x=DOUBLE y=DOUBLE z=DOUBLE)
	 */
	protected void sequence_MH(ISerializationContext context, MH semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyLanguagePackage.Literals.SPEED_UNIT__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLanguagePackage.Literals.SPEED_UNIT__X));
			if (transientValues.isValueTransient(semanticObject, MyLanguagePackage.Literals.SPEED_UNIT__Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLanguagePackage.Literals.SPEED_UNIT__Y));
			if (transientValues.isValueTransient(semanticObject, MyLanguagePackage.Literals.SPEED_UNIT__Z) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLanguagePackage.Literals.SPEED_UNIT__Z));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMHAccess().getXDOUBLEParserRuleCall_1_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getMHAccess().getYDOUBLEParserRuleCall_3_0(), semanticObject.getY());
		feeder.accept(grammarAccess.getMHAccess().getZDOUBLEParserRuleCall_5_0(), semanticObject.getZ());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DistanceUnit returns MILLIMETER
	 *     MILLIMETER returns MILLIMETER
	 *
	 * Constraint:
	 *     value=DOUBLE
	 */
	protected void sequence_MILLIMETER(ISerializationContext context, MILLIMETER semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyLanguagePackage.Literals.DISTANCE_UNIT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLanguagePackage.Literals.DISTANCE_UNIT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMILLIMETERAccess().getValueDOUBLEParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TimeUnit returns MINUTES
	 *     MINUTES returns MINUTES
	 *
	 * Constraint:
	 *     value=PositiveDouble
	 */
	protected void sequence_MINUTES(ISerializationContext context, MINUTES semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyLanguagePackage.Literals.TIME_UNIT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLanguagePackage.Literals.TIME_UNIT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMINUTESAccess().getValuePositiveDoubleParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpeedUnit returns MS
	 *     MS returns MS
	 *
	 * Constraint:
	 *     (x=DOUBLE y=DOUBLE z=DOUBLE)
	 */
	protected void sequence_MS(ISerializationContext context, MS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyLanguagePackage.Literals.SPEED_UNIT__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLanguagePackage.Literals.SPEED_UNIT__X));
			if (transientValues.isValueTransient(semanticObject, MyLanguagePackage.Literals.SPEED_UNIT__Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLanguagePackage.Literals.SPEED_UNIT__Y));
			if (transientValues.isValueTransient(semanticObject, MyLanguagePackage.Literals.SPEED_UNIT__Z) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLanguagePackage.Literals.SPEED_UNIT__Z));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMSAccess().getXDOUBLEParserRuleCall_1_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getMSAccess().getYDOUBLEParserRuleCall_3_0(), semanticObject.getY());
		feeder.accept(grammarAccess.getMSAccess().getZDOUBLEParserRuleCall_5_0(), semanticObject.getZ());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StatementBody returns MissionGoalSent
	 *     MissionSent returns MissionGoalSent
	 *     MissionGoalSent returns MissionGoalSent
	 *
	 * Constraint:
	 *     (posX=DistanceUnit posY=DistanceUnit posZ=DistanceUnit)
	 */
	protected void sequence_MissionGoalSent(ISerializationContext context, MissionGoalSent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyLanguagePackage.Literals.MISSION_GOAL_SENT__POS_X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLanguagePackage.Literals.MISSION_GOAL_SENT__POS_X));
			if (transientValues.isValueTransient(semanticObject, MyLanguagePackage.Literals.MISSION_GOAL_SENT__POS_Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLanguagePackage.Literals.MISSION_GOAL_SENT__POS_Y));
			if (transientValues.isValueTransient(semanticObject, MyLanguagePackage.Literals.MISSION_GOAL_SENT__POS_Z) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLanguagePackage.Literals.MISSION_GOAL_SENT__POS_Z));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMissionGoalSentAccess().getPosXDistanceUnitParserRuleCall_2_0(), semanticObject.getPosX());
		feeder.accept(grammarAccess.getMissionGoalSentAccess().getPosYDistanceUnitParserRuleCall_3_0(), semanticObject.getPosY());
		feeder.accept(grammarAccess.getMissionGoalSentAccess().getPosZDistanceUnitParserRuleCall_4_0(), semanticObject.getPosZ());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StatementBody returns MissionRiskLevelSent
	 *     MissionSent returns MissionRiskLevelSent
	 *     MissionRiskLevelSent returns MissionRiskLevelSent
	 *
	 * Constraint:
	 *     risklevel=MISSIONRISKLEVEL
	 */
	protected void sequence_MissionRiskLevelSent(ISerializationContext context, MissionRiskLevelSent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyLanguagePackage.Literals.MISSION_RISK_LEVEL_SENT__RISKLEVEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLanguagePackage.Literals.MISSION_RISK_LEVEL_SENT__RISKLEVEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMissionRiskLevelSentAccess().getRisklevelMISSIONRISKLEVELParserRuleCall_2_0(), semanticObject.getRisklevel());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StatementBody returns MissionStatusSent
	 *     MissionSent returns MissionStatusSent
	 *     MissionStatusSent returns MissionStatusSent
	 *
	 * Constraint:
	 *     state=MISSIONSTATUS
	 */
	protected void sequence_MissionStatusSent(ISerializationContext context, MissionStatusSent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyLanguagePackage.Literals.MISSION_STATUS_SENT__STATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLanguagePackage.Literals.MISSION_STATUS_SENT__STATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMissionStatusSentAccess().getStateMISSIONSTATUSParserRuleCall_2_0(), semanticObject.getState());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StatementBody returns NotificationSent
	 *     NotificationSent returns NotificationSent
	 *
	 * Constraint:
	 *     not='Notification'
	 */
	protected void sequence_NotificationSent(ISerializationContext context, NotificationSent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyLanguagePackage.Literals.NOTIFICATION_SENT__NOT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLanguagePackage.Literals.NOTIFICATION_SENT__NOT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotificationSentAccess().getNotNotificationKeyword_0_0(), semanticObject.getNot());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StatementBody returns PayloadSent
	 *     Robot returns PayloadSent
	 *     PayloadSent returns PayloadSent
	 *
	 * Constraint:
	 *     load='payload'
	 */
	protected void sequence_PayloadSent(ISerializationContext context, PayloadSent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyLanguagePackage.Literals.PAYLOAD_SENT__LOAD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLanguagePackage.Literals.PAYLOAD_SENT__LOAD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPayloadSentAccess().getLoadPayloadKeyword_0_0(), semanticObject.getLoad());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StatementBody returns PeopleNumbSent
	 *     PeopleSent returns PeopleNumbSent
	 *     PeopleNumbSent returns PeopleNumbSent
	 *
	 * Constraint:
	 *     amount=INT
	 */
	protected void sequence_PeopleNumbSent(ISerializationContext context, PeopleNumbSent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyLanguagePackage.Literals.PEOPLE_NUMB_SENT__AMOUNT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLanguagePackage.Literals.PEOPLE_NUMB_SENT__AMOUNT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPeopleNumbSentAccess().getAmountINTTerminalRuleCall_2_0(), semanticObject.getAmount());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StatementBody returns PeoplePosSent
	 *     PeopleSent returns PeoplePosSent
	 *     PeoplePosSent returns PeoplePosSent
	 *
	 * Constraint:
	 *     (posX=DistanceUnit posY=DistanceUnit posZ=DistanceUnit (tolerance=CirclePosition | tolerance=SpherePosition)?)
	 */
	protected void sequence_PeoplePosSent(ISerializationContext context, PeoplePosSent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PercentUnit returns PercentUnit
	 *
	 * Constraint:
	 *     value=PositiveDouble
	 */
	protected void sequence_PercentUnit(ISerializationContext context, PercentUnit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyLanguagePackage.Literals.PERCENT_UNIT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLanguagePackage.Literals.PERCENT_UNIT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPercentUnitAccess().getValuePositiveDoubleParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StatementBody returns RiskSent
	 *     Robot returns RiskSent
	 *     RiskSent returns RiskSent
	 *
	 * Constraint:
	 *     level=COLLISIONRISKLEVEL
	 */
	protected void sequence_RiskSent(ISerializationContext context, RiskSent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyLanguagePackage.Literals.RISK_SENT__LEVEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLanguagePackage.Literals.RISK_SENT__LEVEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRiskSentAccess().getLevelCOLLISIONRISKLEVELParserRuleCall_2_0(), semanticObject.getLevel());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StatementBody returns RobotAutoPilot
	 *     Robot returns RobotAutoPilot
	 *     RobotAutoPilot returns RobotAutoPilot
	 *
	 * Constraint:
	 *     (status='ON' | status='OFF')
	 */
	protected void sequence_RobotAutoPilot(ISerializationContext context, RobotAutoPilot semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatementBody returns RobotDistanceSent
	 *     Robot returns RobotDistanceSent
	 *     RobotDistanceSent returns RobotDistanceSent
	 *
	 * Constraint:
	 *     (sent=DistanceToObstaclesSent | sent=DistanceToLocationSent)
	 */
	protected void sequence_RobotDistanceSent(ISerializationContext context, RobotDistanceSent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatementBody returns RobotPositionSent
	 *     Robot returns RobotPositionSent
	 *     RobotPositionSent returns RobotPositionSent
	 *
	 * Constraint:
	 *     (posX=DistanceUnit posY=DistanceUnit posZ=DistanceUnit (tolerance=CirclePosition | tolerance=SpherePosition)?)
	 */
	protected void sequence_RobotPositionSent(ISerializationContext context, RobotPositionSent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatementBody returns RobotSpeedSent
	 *     Robot returns RobotSpeedSent
	 *     RobotSpeedSent returns RobotSpeedSent
	 *
	 * Constraint:
	 *     (body=GreaterSent | body=LessSent | body=EqualSent)
	 */
	protected void sequence_RobotSpeedSent(ISerializationContext context, RobotSpeedSent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatementBody returns RobotStateSent
	 *     Robot returns RobotStateSent
	 *     RobotStateSent returns RobotStateSent
	 *
	 * Constraint:
	 *     state=ID
	 */
	protected void sequence_RobotStateSent(ISerializationContext context, RobotStateSent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyLanguagePackage.Literals.ROBOT_STATE_SENT__STATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLanguagePackage.Literals.ROBOT_STATE_SENT__STATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRobotStateSentAccess().getStateIDTerminalRuleCall_2_0(), semanticObject.getState());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TimeUnit returns SECONDS
	 *     SECONDS returns SECONDS
	 *
	 * Constraint:
	 *     value=PositiveDouble
	 */
	protected void sequence_SECONDS(ISerializationContext context, SECONDS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyLanguagePackage.Literals.TIME_UNIT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLanguagePackage.Literals.TIME_UNIT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSECONDSAccess().getValuePositiveDoubleParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SonarDistanceSent returns SonarDistanceSent
	 *
	 * Constraint:
	 *     (sent=GreaterSent | sent=LessSent | sent=EqualSent)
	 */
	protected void sequence_SonarDistanceSent(ISerializationContext context, SonarDistanceSent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatementBody returns SonarSent
	 *     SonarSent returns SonarSent
	 *
	 * Constraint:
	 *     (sent=SonarDistanceSent | sent=CompStatusSent)
	 */
	protected void sequence_SonarSent(ISerializationContext context, SonarSent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SpherePosition returns SpherePosition
	 *
	 * Constraint:
	 *     tolerance=DistanceUnit
	 */
	protected void sequence_SpherePosition(ISerializationContext context, SpherePosition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyLanguagePackage.Literals.SPHERE_POSITION__TOLERANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLanguagePackage.Literals.SPHERE_POSITION__TOLERANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSpherePositionAccess().getToleranceDistanceUnitParserRuleCall_4_0(), semanticObject.getTolerance());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TestFile returns TestFile
	 *
	 * Constraint:
	 *     tests+=Test+
	 */
	protected void sequence_TestFile(ISerializationContext context, TestFile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Test returns Test
	 *
	 * Constraint:
	 *     (name=ID description=STRING? statements+=Statement+)
	 */
	protected void sequence_Test(ISerializationContext context, Test semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Then
	 *     Then returns Then
	 *
	 * Constraint:
	 *     body=StatementBody
	 */
	protected void sequence_Then(ISerializationContext context, Then semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyLanguagePackage.Literals.THEN__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLanguagePackage.Literals.THEN__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getThenAccess().getBodyStatementBodyParserRuleCall_1_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StatementBody returns TimeInterval
	 *     TimeSent returns TimeInterval
	 *     TimeInterval returns TimeInterval
	 *
	 * Constraint:
	 *     (first=TimeUnit second=TimeUnit)
	 */
	protected void sequence_TimeInterval(ISerializationContext context, TimeInterval semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyLanguagePackage.Literals.TIME_INTERVAL__FIRST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLanguagePackage.Literals.TIME_INTERVAL__FIRST));
			if (transientValues.isValueTransient(semanticObject, MyLanguagePackage.Literals.TIME_INTERVAL__SECOND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLanguagePackage.Literals.TIME_INTERVAL__SECOND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimeIntervalAccess().getFirstTimeUnitParserRuleCall_3_0(), semanticObject.getFirst());
		feeder.accept(grammarAccess.getTimeIntervalAccess().getSecondTimeUnitParserRuleCall_5_0(), semanticObject.getSecond());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ToleranceSent returns ToleranceSent
	 *
	 * Constraint:
	 *     unit=DistanceUnit
	 */
	protected void sequence_ToleranceSent(ISerializationContext context, ToleranceSent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyLanguagePackage.Literals.TOLERANCE_SENT__UNIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyLanguagePackage.Literals.TOLERANCE_SENT__UNIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getToleranceSentAccess().getUnitDistanceUnitParserRuleCall_2_0(), semanticObject.getUnit());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns When
	 *     When returns When
	 *
	 * Constraint:
	 *     (body=StatementBody | body=CompleteTimeSent)
	 */
	protected void sequence_When(ISerializationContext context, When semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
