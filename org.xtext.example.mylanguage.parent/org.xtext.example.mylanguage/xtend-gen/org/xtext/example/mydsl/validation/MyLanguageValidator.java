/**
 * generated by Xtext 2.10.0
 */
package org.xtext.example.mydsl.validation;

import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.xtext.example.mydsl.myLanguage.Given;
import org.xtext.example.mydsl.myLanguage.MissionStatusSent;
import org.xtext.example.mydsl.myLanguage.MyLanguagePackage;
import org.xtext.example.mydsl.myLanguage.RobotStateSent;
import org.xtext.example.mydsl.myLanguage.Statement;
import org.xtext.example.mydsl.myLanguage.Test;
import org.xtext.example.mydsl.myLanguage.TestFile;
import org.xtext.example.mydsl.myLanguage.Then;
import org.xtext.example.mydsl.myLanguage.When;
import org.xtext.example.mydsl.myLanguage.impl.GivenImpl;
import org.xtext.example.mydsl.myLanguage.impl.WhenImpl;
import org.xtext.example.mydsl.validation.AbstractMyLanguageValidator;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class MyLanguageValidator extends AbstractMyLanguageValidator {
  private final String INVALID_NAME = "invalidName";
  
  private EObject o;
  
  private TestFile testFile;
  
  @Check
  public void checkCorrectSequence(final Test test) {
    final EList<Statement> statements = test.getStatements();
    for (final Statement s : statements) {
      {
        boolean b = false;
        boolean _matched = false;
        if (s instanceof Given) {
          if ((s instanceof Given)) {
            _matched=true;
            boolean _checkNot = this.checkNot(((Given)s));
            b = _checkNot;
          }
        }
        if (!_matched) {
          if (s instanceof When) {
            if ((s instanceof When)) {
              _matched=true;
              boolean _checkNot = this.checkNot(((When)s), statements);
              b = _checkNot;
            }
          }
        }
        if (!_matched) {
          if (s instanceof Then) {
            if ((s instanceof Then)) {
              _matched=true;
              boolean _checkNot = this.checkNot(((Then)s), statements);
              b = _checkNot;
            }
          }
        }
        if (b) {
          this.error("Correct sequence is Given, When, Then", MyLanguagePackage.Literals.TEST__NAME, this.INVALID_NAME);
        }
      }
    }
  }
  
  public boolean checkNot(final Given statement) {
    return false;
  }
  
  public boolean checkNot(final When statement, final List<Statement> s) {
    final int index = s.indexOf(statement);
    Statement next = s.get(index);
    int _length = ((Object[])Conversions.unwrapArray(s, Object.class)).length;
    int _minus = (_length - 1);
    boolean _lessThan = (index < _minus);
    if (_lessThan) {
      Statement _get = s.get((index + 1));
      next = _get;
    }
    Class<? extends Statement> _class = next.getClass();
    boolean _equals = _class.equals(GivenImpl.class);
    if (_equals) {
      return true;
    } else {
      return false;
    }
  }
  
  public boolean checkNot(final Then statement, final List<Statement> s) {
    final int index = s.indexOf(statement);
    Statement next = s.get(index);
    int _length = ((Object[])Conversions.unwrapArray(s, Object.class)).length;
    int _minus = (_length - 1);
    boolean _lessThan = (index < _minus);
    if (_lessThan) {
      Statement _get = s.get((index + 1));
      next = _get;
    }
    if ((next.getClass().equals(GivenImpl.class) || 
      next.getClass().equals(WhenImpl.class))) {
      return true;
    } else {
      return false;
    }
  }
  
  @Check
  public void checkSameName(final Test test) {
    EObject _eContainer = test.eContainer();
    this.o = _eContainer;
    this.testFile = ((TestFile) this.o);
    final EList<Test> tests = this.testFile.getTests();
    for (final Test t : tests) {
      if (((!t.equals(test)) && test.getName().equals(t.getName()))) {
        this.error("Tests must have different names", MyLanguagePackage.Literals.TEST__NAME, this.INVALID_NAME);
      }
    }
  }
  
  @Check
  public void checkCorrectState(final RobotStateSent sent) {
    final String state = sent.getState();
    if (((((((!state.toString().equals("FLYING")) && (!state.toString().equals("HOVER"))) && (!state.toString().equals("LANDED"))) && (!state.toString().equals("TAKEOFF"))) && (!state.toString().equals("EMERGENCYLANDING"))) && (!state.toString().equals("LANDING")))) {
      this.error("State must be FLYING, HOVER, LANDED, LANDING, EMERGENCYLANDING or TAKEOFF", MyLanguagePackage.Literals.ROBOT_STATE_SENT__STATE, this.INVALID_NAME);
    }
  }
  
  @Check
  public void checkMissionStatus(final MissionStatusSent sent) {
    String _state = sent.getState();
    final String state = _state.toLowerCase();
    if ((((!state.toString().equals("active")) && (!state.toString().equals("unactive"))) && (!state.toString().equals("paused")))) {
      this.error("Must fill in a mission status", MyLanguagePackage.Literals.MISSION_STATUS_SENT__STATE, this.INVALID_NAME);
    }
  }
}
